"""Trade Signals Router - Entry/exit suggestions with position sizing"""
from fastapi import APIRouter, Depends, Query, HTTPException, status
from typing import Optional, List
from datetime import datetime, timedelta, timezone, date
from pydantic import BaseModel, Field
from sqlalchemy import select, desc, and_, func
from sqlalchemy.orm import Session

from api.dependencies import get_db
from api.utils.auth import get_current_user_id, get_current_user_with_plan
from releaseradar.db.models import (
    TradeRecommendation,
    Event,
    EventScore,
    PriceHistory,
    UserPortfolio,
    PortfolioPosition,
    WatchlistItem,
)


router = APIRouter(prefix="/trade-signals", tags=["trade-signals"])

TRADE_SIGNAL_DAILY_LIMITS = {
    "free": 0,
    "pro": 10,
    "team": 40,
}


def get_user_daily_signal_count(db: Session, user_id: int) -> int:
    """Count trade signals generated by user today (UTC)"""
    today_start = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)
    count = db.execute(
        select(func.count(TradeRecommendation.id))
        .where(
            and_(
                TradeRecommendation.user_id == user_id,
                TradeRecommendation.created_at >= today_start
            )
        )
    ).scalar() or 0
    return count


def check_trade_signal_quota(db: Session, user_id: int, plan: str):
    """Check if user has remaining trade signal quota for today"""
    daily_limit = TRADE_SIGNAL_DAILY_LIMITS.get(plan, 0)
    
    if daily_limit == 0:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={
                "error": "Trade signal generation requires a Pro or Team plan",
                "code": "PLAN_UPGRADE_REQUIRED",
                "plan": plan,
                "daily_limit": daily_limit
            }
        )
    
    current_count = get_user_daily_signal_count(db, user_id)
    remaining = daily_limit - current_count
    
    if remaining <= 0:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "error": f"Daily trade signal limit reached ({daily_limit}/{daily_limit}). Resets at midnight UTC.",
                "code": "DAILY_LIMIT_EXCEEDED",
                "plan": plan,
                "daily_limit": daily_limit,
                "used": current_count,
                "remaining": 0
            }
        )
    
    return {"daily_limit": daily_limit, "used": current_count, "remaining": remaining}


class TradeRecommendationResponse(BaseModel):
    """Response model for trade recommendations"""
    id: int
    event_id: int
    ticker: str
    user_id: Optional[int]
    recommendation_type: str
    entry_price_target: Optional[float]
    stop_loss: Optional[float]
    take_profit: Optional[float]
    position_size_pct: Optional[float]
    confidence: float
    risk_reward_ratio: Optional[float]
    holding_period_days: Optional[int]
    rationale: Optional[str]
    expires_at: Optional[datetime]
    created_at: datetime

    class Config:
        from_attributes = True


class TradeRecommendationCreate(BaseModel):
    """Request model for creating trade recommendations"""
    recommendation_type: str = Field(default="entry", description="Type: entry, exit, hold")
    holding_period_days: Optional[int] = Field(default=5, description="Recommended holding period")


class GeneratedRecommendationResponse(BaseModel):
    """Response model for generated trade recommendation"""
    id: int
    event_id: int
    ticker: str
    recommendation_type: str
    entry_price_target: float
    stop_loss: float
    take_profit: float
    position_size_pct: float
    confidence: float
    risk_reward_ratio: float
    holding_period_days: int
    rationale: str
    expires_at: datetime
    created_at: datetime

    class Config:
        from_attributes = True


@router.get(
    "",
    response_model=List[TradeRecommendationResponse],
    summary="List recent trade recommendations",
    description="Retrieve trade recommendations with optional filters for ticker, type, and confidence level."
)
async def list_trade_recommendations(
    ticker: Optional[str] = Query(None, description="Filter by ticker symbol"),
    recommendation_type: Optional[str] = Query(None, description="Filter by type: entry, exit, hold"),
    min_confidence: Optional[float] = Query(None, ge=0.0, le=1.0, description="Minimum confidence level (0-1)"),
    limit: int = Query(50, ge=1, le=200, description="Maximum number of results"),
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """List recent trade recommendations with optional filtering"""
    query = select(TradeRecommendation)
    
    filters = []
    
    if ticker:
        filters.append(TradeRecommendation.ticker == ticker.upper())
    
    if recommendation_type:
        filters.append(TradeRecommendation.recommendation_type == recommendation_type.lower())
    
    if min_confidence is not None:
        filters.append(TradeRecommendation.confidence >= min_confidence)
    
    now = datetime.now(timezone.utc)
    filters.append(
        (TradeRecommendation.expires_at.is_(None)) | (TradeRecommendation.expires_at > now)
    )
    
    if filters:
        query = query.where(and_(*filters))
    
    query = query.order_by(desc(TradeRecommendation.created_at)).limit(limit)
    
    recommendations = db.execute(query).scalars().all()
    
    return [
        TradeRecommendationResponse(
            id=r.id,
            event_id=r.event_id,
            ticker=r.ticker,
            user_id=r.user_id,
            recommendation_type=r.recommendation_type,
            entry_price_target=r.entry_price_target,
            stop_loss=r.stop_loss,
            take_profit=r.take_profit,
            position_size_pct=r.position_size_pct,
            confidence=r.confidence,
            risk_reward_ratio=r.risk_reward_ratio,
            holding_period_days=r.holding_period_days,
            rationale=r.rationale,
            expires_at=r.expires_at,
            created_at=r.created_at,
        )
        for r in recommendations
    ]


@router.get(
    "/event/{event_id}",
    response_model=TradeRecommendationResponse,
    summary="Get trade recommendation for event",
    description="Retrieve the trade recommendation associated with a specific event."
)
async def get_recommendation_for_event(
    event_id: int,
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Get trade recommendation for a specific event"""
    recommendation = db.execute(
        select(TradeRecommendation).where(TradeRecommendation.event_id == event_id)
    ).scalar_one_or_none()
    
    if not recommendation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"No trade recommendation found for event {event_id}"
        )
    
    return TradeRecommendationResponse(
        id=recommendation.id,
        event_id=recommendation.event_id,
        ticker=recommendation.ticker,
        user_id=recommendation.user_id,
        recommendation_type=recommendation.recommendation_type,
        entry_price_target=recommendation.entry_price_target,
        stop_loss=recommendation.stop_loss,
        take_profit=recommendation.take_profit,
        position_size_pct=recommendation.position_size_pct,
        confidence=recommendation.confidence,
        risk_reward_ratio=recommendation.risk_reward_ratio,
        holding_period_days=recommendation.holding_period_days,
        rationale=recommendation.rationale,
        expires_at=recommendation.expires_at,
        created_at=recommendation.created_at,
    )


@router.post(
    "/generate/{event_id}",
    response_model=GeneratedRecommendationResponse,
    summary="Generate trade recommendation for event",
    description="""
    Generate a trade recommendation for a specific event using event scores and price data.
    
    Calculates:
    - entry_price_target: Current price from price history
    - stop_loss: Based on ATR or fixed 5% below entry
    - take_profit: Based on predicted impact score
    - position_size_pct: Based on confidence (1-5%)
    - risk_reward_ratio: (take_profit - entry) / (entry - stop_loss)
    """
)
async def generate_trade_recommendation(
    event_id: int,
    request: TradeRecommendationCreate = None,
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Generate trade recommendation for an event based on event scores and price data"""
    user_id = user["user_id"]
    plan = user.get("plan", "free")
    
    quota_info = check_trade_signal_quota(db, user_id, plan)
    
    if request is None:
        request = TradeRecommendationCreate()
    
    event = db.execute(
        select(Event).where(Event.id == event_id)
    ).scalar_one_or_none()
    
    if not event:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Event {event_id} not found"
        )
    
    existing = db.execute(
        select(TradeRecommendation).where(TradeRecommendation.event_id == event_id)
    ).scalar_one_or_none()
    
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Trade recommendation already exists for event {event_id}"
        )
    
    event_score = db.execute(
        select(EventScore).where(EventScore.event_id == event_id)
    ).scalar_one_or_none()
    
    final_score = event_score.final_score if event_score else event.impact_score
    confidence_from_score = (event_score.confidence / 100.0) if event_score else event.confidence
    
    today = date.today()
    lookback_days = 30
    start_date = today - timedelta(days=lookback_days)
    
    price_history = db.execute(
        select(PriceHistory)
        .where(PriceHistory.ticker == event.ticker)
        .where(PriceHistory.date >= start_date)
        .order_by(desc(PriceHistory.date))
    ).scalars().all()
    
    if not price_history:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"No price history available for {event.ticker}. Cannot generate recommendation."
        )
    
    current_price = price_history[0].close
    entry_price_target = current_price
    
    if len(price_history) >= 14:
        tr_values = []
        for i in range(1, min(15, len(price_history))):
            high = price_history[i-1].high
            low = price_history[i-1].low
            prev_close = price_history[i].close
            tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
            tr_values.append(tr)
        atr = sum(tr_values) / len(tr_values) if tr_values else current_price * 0.05
        stop_loss_distance = atr * 2.0
    else:
        stop_loss_distance = current_price * 0.05
    
    direction = event.direction or (event_score.event.direction if event_score and event_score.event else "positive")
    is_bullish = direction in ["positive", "bullish", "up"]
    
    if is_bullish:
        stop_loss = round(current_price - stop_loss_distance, 2)
        impact_multiplier = min(final_score / 50.0, 3.0)
        take_profit_distance = stop_loss_distance * impact_multiplier * 1.5
        take_profit = round(current_price + take_profit_distance, 2)
    else:
        stop_loss = round(current_price + stop_loss_distance, 2)
        impact_multiplier = min(final_score / 50.0, 3.0)
        take_profit_distance = stop_loss_distance * impact_multiplier * 1.5
        take_profit = round(current_price - take_profit_distance, 2)
    
    if is_bullish:
        risk = entry_price_target - stop_loss
        reward = take_profit - entry_price_target
    else:
        risk = stop_loss - entry_price_target
        reward = entry_price_target - take_profit
    
    risk_reward_ratio = round(reward / risk, 2) if risk > 0 else 1.0
    
    confidence = min(confidence_from_score, 1.0)
    base_position = 1.0
    position_size_pct = round(base_position + (confidence * 4.0), 2)
    position_size_pct = min(max(position_size_pct, 1.0), 5.0)
    
    holding_period_days = request.holding_period_days or 5
    
    direction_word = "bullish" if is_bullish else "bearish"
    rationale = (
        f"Based on {event.event_type} event with impact score {final_score} and {direction_word} direction. "
        f"Entry at ${entry_price_target:.2f} with {stop_loss_distance/current_price*100:.1f}% stop-loss distance. "
        f"Risk/reward ratio of {risk_reward_ratio:.2f}. "
        f"Confidence: {confidence*100:.0f}%, Position size: {position_size_pct:.1f}% of portfolio."
    )
    
    expires_at = datetime.now(timezone.utc) + timedelta(days=holding_period_days + 2)
    
    recommendation = TradeRecommendation(
        event_id=event_id,
        ticker=event.ticker,
        user_id=user_id,
        recommendation_type=request.recommendation_type,
        entry_price_target=entry_price_target,
        stop_loss=stop_loss,
        take_profit=take_profit,
        position_size_pct=position_size_pct,
        confidence=confidence,
        risk_reward_ratio=risk_reward_ratio,
        holding_period_days=holding_period_days,
        rationale=rationale,
        expires_at=expires_at,
    )
    
    db.add(recommendation)
    db.commit()
    db.refresh(recommendation)
    
    return GeneratedRecommendationResponse(
        id=recommendation.id,
        event_id=recommendation.event_id,
        ticker=recommendation.ticker,
        recommendation_type=recommendation.recommendation_type,
        entry_price_target=recommendation.entry_price_target,
        stop_loss=recommendation.stop_loss,
        take_profit=recommendation.take_profit,
        position_size_pct=recommendation.position_size_pct,
        confidence=recommendation.confidence,
        risk_reward_ratio=recommendation.risk_reward_ratio,
        holding_period_days=recommendation.holding_period_days,
        rationale=recommendation.rationale,
        expires_at=recommendation.expires_at,
        created_at=recommendation.created_at,
    )


class TradeSignalQuotaResponse(BaseModel):
    """Response model for trade signal quota status"""
    plan: str
    daily_limit: int
    used: int
    remaining: int
    resets_at: str


@router.get(
    "/quota",
    response_model=TradeSignalQuotaResponse,
    summary="Get trade signal generation quota",
    description="Check remaining daily trade signal generation quota for the current user."
)
async def get_trade_signal_quota(
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Get the user's trade signal generation quota status"""
    user_id = user["user_id"]
    plan = user.get("plan", "free")
    
    daily_limit = TRADE_SIGNAL_DAILY_LIMITS.get(plan, 0)
    used = get_user_daily_signal_count(db, user_id)
    remaining = max(0, daily_limit - used)
    
    tomorrow_utc = (datetime.now(timezone.utc) + timedelta(days=1)).replace(
        hour=0, minute=0, second=0, microsecond=0
    )
    
    return TradeSignalQuotaResponse(
        plan=plan,
        daily_limit=daily_limit,
        used=used,
        remaining=remaining,
        resets_at=tomorrow_utc.isoformat()
    )


@router.get(
    "/portfolio",
    response_model=List[TradeRecommendationResponse],
    summary="Get trade signals for portfolio",
    description="Retrieve trade recommendations for tickers in user's portfolios."
)
async def get_portfolio_trade_signals(
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Get trade recommendations for tickers in user's portfolios"""
    user_id = user["user_id"]
    
    portfolios = db.execute(
        select(UserPortfolio).where(UserPortfolio.user_id == user_id)
    ).scalars().all()
    
    if not portfolios:
        return []
    
    portfolio_ids = [p.id for p in portfolios]
    
    positions = db.execute(
        select(PortfolioPosition).where(PortfolioPosition.portfolio_id.in_(portfolio_ids))
    ).scalars().all()
    
    if not positions:
        return []
    
    tickers = list(set(p.ticker for p in positions))
    
    now = datetime.now(timezone.utc)
    recommendations = db.execute(
        select(TradeRecommendation)
        .where(TradeRecommendation.ticker.in_(tickers))
        .where(
            (TradeRecommendation.expires_at.is_(None)) | (TradeRecommendation.expires_at > now)
        )
        .order_by(desc(TradeRecommendation.created_at))
    ).scalars().all()
    
    return [
        TradeRecommendationResponse(
            id=r.id,
            event_id=r.event_id,
            ticker=r.ticker,
            user_id=r.user_id,
            recommendation_type=r.recommendation_type,
            entry_price_target=r.entry_price_target,
            stop_loss=r.stop_loss,
            take_profit=r.take_profit,
            position_size_pct=r.position_size_pct,
            confidence=r.confidence,
            risk_reward_ratio=r.risk_reward_ratio,
            holding_period_days=r.holding_period_days,
            rationale=r.rationale,
            expires_at=r.expires_at,
            created_at=r.created_at,
        )
        for r in recommendations
    ]


class PortfolioGenerationResponse(BaseModel):
    """Response model for portfolio signal generation"""
    generated_count: int
    skipped_count: int
    errors: List[str]
    recommendations: List[GeneratedRecommendationResponse]


@router.post(
    "/generate-portfolio",
    response_model=PortfolioGenerationResponse,
    summary="Generate trade signals for portfolio",
    description="""
    Generate trade recommendations for all tickers in user's portfolios.
    Finds recent events for portfolio tickers and generates recommendations for each.
    Skips events that already have recommendations.
    """
)
async def generate_portfolio_trade_signals(
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Generate trade recommendations for all portfolio tickers"""
    user_id = user["user_id"]
    
    portfolios = db.execute(
        select(UserPortfolio).where(UserPortfolio.user_id == user_id)
    ).scalars().all()
    
    if not portfolios:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No portfolios found. Please create a portfolio first."
        )
    
    portfolio_ids = [p.id for p in portfolios]
    
    positions = db.execute(
        select(PortfolioPosition).where(PortfolioPosition.portfolio_id.in_(portfolio_ids))
    ).scalars().all()
    
    if not positions:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No positions in your portfolios. Please add tickers to your portfolio first."
        )
    
    tickers = list(set(p.ticker for p in positions))
    
    lookback = datetime.now(timezone.utc) - timedelta(days=30)
    recent_events = db.execute(
        select(Event)
        .where(Event.ticker.in_(tickers))
        .where(Event.date >= lookback)
        .order_by(desc(Event.date))
    ).scalars().all()
    
    if not recent_events:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No recent events found for your portfolio tickers in the last 30 days."
        )
    
    existing_event_ids = set(
        db.execute(
            select(TradeRecommendation.event_id)
            .where(TradeRecommendation.event_id.in_([e.id for e in recent_events]))
        ).scalars().all()
    )
    
    generated = []
    errors = []
    skipped = 0
    
    for event in recent_events:
        if event.id in existing_event_ids:
            skipped += 1
            continue
        
        try:
            today = date.today()
            start_date = today - timedelta(days=30)
            
            price_history = db.execute(
                select(PriceHistory)
                .where(PriceHistory.ticker == event.ticker)
                .where(PriceHistory.date >= start_date)
                .order_by(desc(PriceHistory.date))
            ).scalars().all()
            
            if not price_history:
                errors.append(f"No price history for {event.ticker}")
                continue
            
            event_score = db.execute(
                select(EventScore).where(EventScore.event_id == event.id)
            ).scalar_one_or_none()
            
            final_score = event_score.final_score if event_score else event.impact_score
            confidence_from_score = (event_score.confidence / 100.0) if event_score else event.confidence
            
            current_price = price_history[0].close
            entry_price_target = current_price
            
            if len(price_history) >= 14:
                tr_values = []
                for i in range(1, min(15, len(price_history))):
                    high = price_history[i-1].high
                    low = price_history[i-1].low
                    prev_close = price_history[i].close
                    tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
                    tr_values.append(tr)
                atr = sum(tr_values) / len(tr_values) if tr_values else current_price * 0.05
                stop_loss_distance = atr * 2.0
            else:
                stop_loss_distance = current_price * 0.05
            
            direction = event.direction or "positive"
            is_bullish = direction in ["positive", "bullish", "up"]
            
            if is_bullish:
                stop_loss = round(current_price - stop_loss_distance, 2)
                impact_multiplier = min(final_score / 50.0, 3.0)
                take_profit_distance = stop_loss_distance * impact_multiplier * 1.5
                take_profit = round(current_price + take_profit_distance, 2)
            else:
                stop_loss = round(current_price + stop_loss_distance, 2)
                impact_multiplier = min(final_score / 50.0, 3.0)
                take_profit_distance = stop_loss_distance * impact_multiplier * 1.5
                take_profit = round(current_price - take_profit_distance, 2)
            
            if is_bullish:
                risk = entry_price_target - stop_loss
                reward = take_profit - entry_price_target
            else:
                risk = stop_loss - entry_price_target
                reward = entry_price_target - take_profit
            
            risk_reward_ratio = round(reward / risk, 2) if risk > 0 else 1.0
            
            confidence = min(confidence_from_score, 1.0)
            base_position = 1.0
            position_size_pct = round(base_position + (confidence * 4.0), 2)
            position_size_pct = min(max(position_size_pct, 1.0), 5.0)
            
            holding_period_days = 5
            
            direction_word = "bullish" if is_bullish else "bearish"
            rationale = (
                f"Based on {event.event_type} event with impact score {final_score} and {direction_word} direction. "
                f"Entry at ${entry_price_target:.2f} with {stop_loss_distance/current_price*100:.1f}% stop-loss distance. "
                f"Risk/reward ratio of {risk_reward_ratio:.2f}. "
                f"Confidence: {confidence*100:.0f}%, Position size: {position_size_pct:.1f}% of portfolio."
            )
            
            expires_at = datetime.now(timezone.utc) + timedelta(days=holding_period_days + 2)
            
            recommendation = TradeRecommendation(
                event_id=event.id,
                ticker=event.ticker,
                user_id=user_id,
                recommendation_type="entry",
                entry_price_target=entry_price_target,
                stop_loss=stop_loss,
                take_profit=take_profit,
                position_size_pct=position_size_pct,
                confidence=confidence,
                risk_reward_ratio=risk_reward_ratio,
                holding_period_days=holding_period_days,
                rationale=rationale,
                expires_at=expires_at,
            )
            
            db.add(recommendation)
            db.commit()
            db.refresh(recommendation)
            
            generated.append(GeneratedRecommendationResponse(
                id=recommendation.id,
                event_id=recommendation.event_id,
                ticker=recommendation.ticker,
                recommendation_type=recommendation.recommendation_type,
                entry_price_target=recommendation.entry_price_target,
                stop_loss=recommendation.stop_loss,
                take_profit=recommendation.take_profit,
                position_size_pct=recommendation.position_size_pct,
                confidence=recommendation.confidence,
                risk_reward_ratio=recommendation.risk_reward_ratio,
                holding_period_days=recommendation.holding_period_days,
                rationale=recommendation.rationale,
                expires_at=recommendation.expires_at,
                created_at=recommendation.created_at,
            ))
            
        except Exception as e:
            errors.append(f"Error for {event.ticker} event {event.id}: {str(e)}")
            db.rollback()
            continue
    
    return PortfolioGenerationResponse(
        generated_count=len(generated),
        skipped_count=skipped,
        errors=errors,
        recommendations=generated
    )


@router.post(
    "/generate-watchlist",
    response_model=PortfolioGenerationResponse,
    summary="Generate trade signals for watchlist",
    description="""
    Generate trade recommendations for all tickers in user's watchlist.
    Finds recent events for watchlist tickers and generates recommendations for each.
    Skips events that already have recommendations.
    """
)
async def generate_watchlist_trade_signals(
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Generate trade recommendations for all watchlist tickers"""
    user_id = user["user_id"]
    plan = user.get("plan", "free")
    
    check_trade_signal_quota(db, user_id, plan)
    
    watchlist_items = db.execute(
        select(WatchlistItem).where(WatchlistItem.user_id == user_id)
    ).scalars().all()
    
    if not watchlist_items:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No tickers in your watchlist. Please add stocks to your watchlist first."
        )
    
    tickers = list(set(item.ticker for item in watchlist_items))
    
    lookback = datetime.now(timezone.utc) - timedelta(days=30)
    recent_events = db.execute(
        select(Event)
        .where(Event.ticker.in_(tickers))
        .where(Event.date >= lookback)
        .order_by(desc(Event.date))
    ).scalars().all()
    
    if not recent_events:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No recent events found for your watchlist tickers in the last 30 days."
        )
    
    existing_event_ids = set(
        db.execute(
            select(TradeRecommendation.event_id)
            .where(TradeRecommendation.event_id.in_([e.id for e in recent_events]))
        ).scalars().all()
    )
    
    generated = []
    errors = []
    skipped = 0
    
    for event in recent_events:
        if event.id in existing_event_ids:
            skipped += 1
            continue
        
        try:
            today = date.today()
            start_date = today - timedelta(days=30)
            
            price_history = db.execute(
                select(PriceHistory)
                .where(PriceHistory.ticker == event.ticker)
                .where(PriceHistory.date >= start_date)
                .order_by(desc(PriceHistory.date))
            ).scalars().all()
            
            if not price_history:
                errors.append(f"No price history for {event.ticker}")
                continue
            
            event_score = db.execute(
                select(EventScore).where(EventScore.event_id == event.id)
            ).scalar_one_or_none()
            
            final_score = event_score.final_score if event_score else event.impact_score
            confidence_from_score = (event_score.confidence / 100.0) if event_score else event.confidence
            
            current_price = price_history[0].close
            entry_price_target = current_price
            
            if len(price_history) >= 14:
                tr_values = []
                for i in range(1, min(15, len(price_history))):
                    high = price_history[i-1].high
                    low = price_history[i-1].low
                    prev_close = price_history[i].close
                    tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
                    tr_values.append(tr)
                atr = sum(tr_values) / len(tr_values) if tr_values else current_price * 0.05
                stop_loss_distance = atr * 2.0
            else:
                stop_loss_distance = current_price * 0.05
            
            direction = event.direction or "positive"
            is_bullish = direction in ["positive", "bullish", "up"]
            
            if is_bullish:
                stop_loss = round(current_price - stop_loss_distance, 2)
                impact_multiplier = min(final_score / 50.0, 3.0)
                take_profit_distance = stop_loss_distance * impact_multiplier * 1.5
                take_profit = round(current_price + take_profit_distance, 2)
            else:
                stop_loss = round(current_price + stop_loss_distance, 2)
                impact_multiplier = min(final_score / 50.0, 3.0)
                take_profit_distance = stop_loss_distance * impact_multiplier * 1.5
                take_profit = round(current_price - take_profit_distance, 2)
            
            if is_bullish:
                risk = entry_price_target - stop_loss
                reward = take_profit - entry_price_target
            else:
                risk = stop_loss - entry_price_target
                reward = entry_price_target - take_profit
            
            risk_reward_ratio = round(reward / risk, 2) if risk > 0 else 1.0
            
            confidence = min(confidence_from_score, 1.0)
            base_position = 1.0
            position_size_pct = round(base_position + (confidence * 4.0), 2)
            position_size_pct = min(max(position_size_pct, 1.0), 5.0)
            
            holding_period_days = 5
            
            direction_word = "bullish" if is_bullish else "bearish"
            rationale = (
                f"[Watchlist] Based on {event.event_type} event with impact score {final_score} and {direction_word} direction. "
                f"Entry at ${entry_price_target:.2f} with {stop_loss_distance/current_price*100:.1f}% stop-loss distance. "
                f"Risk/reward ratio of {risk_reward_ratio:.2f}. "
                f"Confidence: {confidence*100:.0f}%, Position size: {position_size_pct:.1f}% of portfolio."
            )
            
            expires_at = datetime.now(timezone.utc) + timedelta(days=holding_period_days + 2)
            
            recommendation = TradeRecommendation(
                event_id=event.id,
                ticker=event.ticker,
                user_id=user_id,
                recommendation_type="entry",
                entry_price_target=entry_price_target,
                stop_loss=stop_loss,
                take_profit=take_profit,
                position_size_pct=position_size_pct,
                confidence=confidence,
                risk_reward_ratio=risk_reward_ratio,
                holding_period_days=holding_period_days,
                rationale=rationale,
                expires_at=expires_at,
            )
            
            db.add(recommendation)
            db.commit()
            db.refresh(recommendation)
            
            generated.append(GeneratedRecommendationResponse(
                id=recommendation.id,
                event_id=recommendation.event_id,
                ticker=recommendation.ticker,
                recommendation_type=recommendation.recommendation_type,
                entry_price_target=recommendation.entry_price_target,
                stop_loss=recommendation.stop_loss,
                take_profit=recommendation.take_profit,
                position_size_pct=recommendation.position_size_pct,
                confidence=recommendation.confidence,
                risk_reward_ratio=recommendation.risk_reward_ratio,
                holding_period_days=recommendation.holding_period_days,
                rationale=recommendation.rationale,
                expires_at=recommendation.expires_at,
                created_at=recommendation.created_at,
            ))
            
        except Exception as e:
            errors.append(f"Error for {event.ticker} event {event.id}: {str(e)}")
            db.rollback()
            continue
    
    return PortfolioGenerationResponse(
        generated_count=len(generated),
        skipped_count=skipped,
        errors=errors,
        recommendations=generated
    )


@router.get(
    "/watchlist",
    response_model=List[TradeRecommendationResponse],
    summary="Get trade signals for watchlist tickers",
    description="Get active trade recommendations for tickers in user's watchlist"
)
async def get_watchlist_trade_signals(
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Get trade recommendations for watchlist tickers"""
    user_id = user["user_id"]
    
    watchlist_items = db.execute(
        select(WatchlistItem).where(WatchlistItem.user_id == user_id)
    ).scalars().all()
    
    if not watchlist_items:
        return []
    
    tickers = [item.ticker for item in watchlist_items]
    
    now = datetime.now(timezone.utc)
    recommendations = db.execute(
        select(TradeRecommendation)
        .where(TradeRecommendation.ticker.in_(tickers))
        .where(
            (TradeRecommendation.expires_at.is_(None)) | (TradeRecommendation.expires_at > now)
        )
        .order_by(desc(TradeRecommendation.created_at))
    ).scalars().all()
    
    return [
        TradeRecommendationResponse(
            id=r.id,
            event_id=r.event_id,
            ticker=r.ticker,
            user_id=r.user_id,
            recommendation_type=r.recommendation_type,
            entry_price_target=r.entry_price_target,
            stop_loss=r.stop_loss,
            take_profit=r.take_profit,
            position_size_pct=r.position_size_pct,
            confidence=r.confidence,
            risk_reward_ratio=r.risk_reward_ratio,
            holding_period_days=r.holding_period_days,
            rationale=r.rationale,
            expires_at=r.expires_at,
            created_at=r.created_at,
        )
        for r in recommendations
    ]


@router.delete(
    "/{recommendation_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete trade recommendation",
    description="Delete a specific trade recommendation by ID."
)
async def delete_trade_recommendation(
    recommendation_id: int,
    db: Session = Depends(get_db),
    user=Depends(get_current_user_with_plan),
):
    """Delete a trade recommendation"""
    recommendation = db.execute(
        select(TradeRecommendation).where(TradeRecommendation.id == recommendation_id)
    ).scalar_one_or_none()
    
    if not recommendation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Trade recommendation {recommendation_id} not found"
        )
    
    if recommendation.user_id and recommendation.user_id != user["user_id"] and not user.get("is_admin"):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only delete your own recommendations"
        )
    
    db.delete(recommendation)
    db.commit()
    
    return None
